{"componentChunkName":"component---src-templates-blog-post-js","path":"/fraud-detection/","result":{"data":{"site":{"siteMetadata":{"title":"santos-luis.github.io"}},"markdownRemark":{"id":"1e0381f6-8884-52e0-9d19-c02a8b211a5c","excerpt":"The Problem: While working at an online marketplace, one of the challenges encountered are the detection of frauds. Those frauds can, usually, be either: A…","html":"<h2>The Problem:</h2>\n<p>While working at an online marketplace, one of the challenges encountered are the detection of frauds. Those frauds can, usually, be either:</p>\n<ol>\n<li>A person trying to sell out of the online platform, in order to avoid taxes/service fees;</li>\n<li>A scam, where the object/product sold it’s not what is being announced or doesn’t even exist.</li>\n</ol>\n<p>At <a href=\"https://www.uniplaces.com/\">Uniplaces</a>, the landlord and the tenant have no communication until the booking is confirmed on both sides. This made few landlords trying to bypass our restrictions and made tenants talk directly with them before the booking is done, avoiding our service fees. The most common way was to put the email/phone number on one of the images or even in the house description.</p>\n<p>We also had multiple of the <em>type 2</em> cases, being most of them catch by our team but some of them actually resulting in a fraudulent case, where the tenant transferred the money to a scammer and got ghosted right after. </p>\n<h2>The Solution:</h2>\n<p>When a new property is added to our product, the landlord needs to upload multiple photos of the house. All those photos pass by our core system and then are stored on a cloud service.</p>\n<p>Since we didn’t want to add the logic of fraudulent offers to our core system, we decided to create an external service that would receive all the photos and then decide if the house published should be considered fraudulent or not. If so, that external service communicates again with our core system telling to unpublish the house offer.</p>\n<p>Having in mind this new service wouldn’t be in use all the time, and only would have to handle API requests, we decided to go to a serverless approach, more specific, an AWS lambda. Also, since we didn’t have the need of this service to be in real time (it could take several seconds to process the information), we also went to a queue approach, making all the process asynchronous.</p>\n<p>In terms of optical character recognition (to extract the text from the image), the system is using the Google Cloud Vision API, which receives an image, configurable parameters (e.g., the type of algorithm and the type of document) and returns the text that is present on the image. By the time of development, we had more options on the table, but Google Cloud Vision API seemed to be best in terms of configurability, easy to use, and also in terms of pricing to our model.</p>\n<p>The solution can be illustrated as follows:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c1f4e05fa3409a1cfe226a4767520e0e/53639/architecture.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.93670886075949%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABGklEQVQoz51SvU7DMBjMA7HwgIgNiQdgZGDIKzAgUSFURgQSQ5XICKFGah0ciDFN4/jnIK6TuKXt0JM+Wd/57uTPdgQPa61fATZ/g5IV+r0yg+WzTohWWdB3yKVY87aI8jxHmqYQ4tsRU/KI+OQIeXLtjKolX++AhwsYb5pPJ4hPj5E9xa7/+ixACAFjDBHnHJRS1HXtNkuWIR2doSmJCzTGgGcJiskYTcWdRpQUyegcNXtx/bJauAwhBCIE6Mf21UFqC2k8908TKv9GbkO66kM3OK01lFL9HXealQ4IM7YGDr31B9K+EPDbPWsjb8KYlWGcGFzdN4F5t2dn4GBUuH3muLz5gNFyGPmQQPcgskFT/0DLRf8T9gX+As6wvGe/5GvbAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Architecture\"\n        title=\"Architecture\"\n        src=\"/static/c1f4e05fa3409a1cfe226a4767520e0e/f058b/architecture.png\"\n        srcset=\"/static/c1f4e05fa3409a1cfe226a4767520e0e/c26ae/architecture.png 158w,\n/static/c1f4e05fa3409a1cfe226a4767520e0e/6bdcf/architecture.png 315w,\n/static/c1f4e05fa3409a1cfe226a4767520e0e/f058b/architecture.png 630w,\n/static/c1f4e05fa3409a1cfe226a4767520e0e/40601/architecture.png 945w,\n/static/c1f4e05fa3409a1cfe226a4767520e0e/78612/architecture.png 1260w,\n/static/c1f4e05fa3409a1cfe226a4767520e0e/53639/architecture.png 1358w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>","frontmatter":{"title":"Fraud Detection","date":"April 08, 2019","description":"The project was developed using Symfony and an AWS lambda, having the purpose of detecting phone numbers/emails in photos. To get the text present on the image, we were doing OCR (optical character recognition) using the google cloud vision API and doing some logic to filter the patterns on the text. In terms of deployment process the project is using the serverless framework."}}},"pageContext":{"slug":"/fraud-detection/","previous":null,"next":{"fields":{"slug":"/price-recommendations/"},"frontmatter":{"title":"Price Recommendations"}}}},"staticQueryHashes":["3000541721","521915702"]}